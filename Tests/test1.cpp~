#include "epot_bicgstabsolver.hpp"
#include "particledatabase.hpp"
#include "geometry.hpp"
#include "func_solid.hpp"
#include "epot_efield.hpp"
#include "meshvectorfield.hpp"
#include "ibsimu.hpp"
#include "error.hpp"
#include "particlediagplotter.hpp"
#include "geomplotter.hpp"
#include "config.h"
#include "gtkplotter.hpp"
#include <iostream>
#include <fstream>
#include <iomanip>
#include <limits>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

const double Te = 5.0;
const double Ti = 1;
const double Up = 5.0;

const double a = 0.009;
const double b = 0.002;
const double t1 = 0.002;
const double t2 = 0.003;

const double Vext = -10e3;
const double dVgg = 300.0;

const double J = 330.0;

const double lSim = 0.001 + t1 + a + t2 + b + t2 + 0.001;
const double wSim = 0.044;
const double hSim = 0.008;
const double lMesh = 0.0002;
const int nCellW = (int)(wSim/lMesh)+1;
const int nCellH = (int)(hSim/lMesh)+1;
const int nCellL = (int)(lSim/lMesh)+1;
const int N = nCellW * nCellH * 30;


bool solid1( double x, double y, double z )
{
  return ( (z <= 0.001 + t1 && z >= 0.001) &&
	   ((x <= -0.02 || x >= 0.02 || y <= -0.00296 || y >= 0.00296) ||
	   ((z >= 0.001 && z <= 0.0024) && !(abs(x) <= 0.018 || abs(x) <= 5*z + 0.008)) ||
	    ((z >= 0.001 && z <= 0.0024) && !(abs(y) <= 0.002 ||  abs(y) <= 2.4*z - 0.0028))
	    ));
}

bool solid2( double x, double y, double z )
{
    return  ( z <= a + t1 + t2 + 0.001 && z >= a + t1 + 0.001 &&
              (y >= 0.0015 || y <= -0.0015 || x >= 0.02 || x <= -0.02)
	      );
}

bool solid3( double x, double y, double z )
{
    return  ( z <= a + t1 + t2 + t2 + b + 0.001 && z >= a + 0.001 + t1 + t2 + b &&
              (y >= 0.0018 || y <= -0.0018 || x >= 0.02 || x <= -0.02)
	      );
}

void simu( int *argc, char ***argv )
{
  Geometry geom( MODE_3D, Int3D(nCellW,nCellH,nCellL), Vec3D(-wSim/2,-hSim/2,0), lMesh);
    Solid *s1 = new FuncSolid( solid1 );
    geom.set_solid( 7, s1 );
    Solid *s2 = new FuncSolid( solid2 );
    geom.set_solid( 8, s2 );
    Solid *s3 = new FuncSolid( solid3 );
    geom.set_solid( 9, s3 );
    geom.set_boundary( 1, Bound(BOUND_NEUMANN,    0.0) );
    geom.set_boundary( 2, Bound(BOUND_NEUMANN,    0.0) );
    geom.set_boundary( 3, Bound(BOUND_NEUMANN,    0.0) );
    geom.set_boundary( 4, Bound(BOUND_NEUMANN,    0.0) );
    geom.set_boundary( 5, Bound(BOUND_NEUMANN,    0.0) );
    geom.set_boundary( 6, Bound(BOUND_DIRICHLET,    Vext) );
    geom.set_boundary( 7, Bound(BOUND_DIRICHLET,  Up)  );
    geom.set_boundary( 8, Bound(BOUND_DIRICHLET, Vext - dVgg) );
    geom.set_boundary( 9, Bound(BOUND_DIRICHLET, Vext) );
    geom.build_mesh();
    
    EpotBiCGSTABSolver solver( geom );
    InitialPlasma initp( AXIS_Z, 3e-3 );
    solver.set_initial_plasma( Up, &initp );

    EpotField epot( geom );
    MeshScalarField scharge( geom );
    MeshVectorField bfield;
    EpotEfield efield( epot );
    field_extrpl_e efldextrpl[6] = { FIELD_EXTRAPOLATE, FIELD_EXTRAPOLATE, 
				     FIELD_EXTRAPOLATE, FIELD_EXTRAPOLATE,
				     FIELD_EXTRAPOLATE, FIELD_EXTRAPOLATE };
    efield.set_extrapolation( efldextrpl );

    ParticleDataBase3D pdb( geom );
    bool pmirror[6] = { false, false, false, false, false, false };
    pdb.set_mirror( pmirror );

    for( size_t i = 0; i < 15; i++ ) {

	if( i == 1 ) {
	    double rhoe = pdb.get_rhosum();
	    solver.set_pexp_plasma( -rhoe, Te, Up );
	}

	solver.solve( epot, scharge );
	efield.recalculate();

	pdb.clear();
	pdb.add_rectangular_beam_with_energy( N/3, J/3, 1.0, 1.0, 
					      5.0, Ti, Ti, 
					      Vec3D(0,0,0), Vec3D(1,0,0), Vec3D(0,1,0), 
					      wSim/2, hSim/2);
	pdb.add_rectangular_beam_with_energy( N/3, J/3, 1.0, 2.0, 
					      5.0, Ti, Ti, 
					      Vec3D(0,0,0), Vec3D(1,0,0), Vec3D(0,1,0), 
					      wSim/2, hSim/2);
	pdb.add_rectangular_beam_with_energy( N/3, J/3, 1.0, 3.0, 
					      5.0, Ti, Ti, 
					      Vec3D(0,0,0), Vec3D(1,0,0), Vec3D(0,1,0), 
					      wSim/2, hSim/2 );
	pdb.iterate_trajectories( scharge, efield, bfield );

	if (i == 13){
	  GeomPlotter geomplotter1( geom );
	  geomplotter1.set_size( 1280, 1280 );
	  geomplotter1.set_epot( &epot );
	  geomplotter1.set_particle_database( &pdb );
	  geomplotter1.set_view( VIEW_ZY);
	  geomplotter1.plot_png( "plot_zy_test.png" );
	}
    }
    
    geom.save( "geom.dat" );
    epot.save( "epot.dat" );
    pdb.save( "pdb.dat" );

    // Write output file containing parameters
    std::ofstream fileOut( "parameters.txt" );
    std::string astr;
    astr = std::to_string(a * 1000);
    astr.erase(std::remove(astr.begin(), astr.end(), '.'), astr.end());
    astr.erase(astr.find_last_not_of("0") + 1, std::string::npos);
    std::string Tstr;
    Tstr = std::to_string(Ti);
    std::replace(Tstr.begin(), Tstr.end(), '.','-');
    Tstr.erase(Tstr.find_last_not_of("0") + 1, std::string::npos);
    fileOut << "J" << J << "a" << astr << "N" << N << "T" << Tstr << "\n";
    fileOut << lSim << "\n";
    fileOut << "a: " << a << ",   ";
    fileOut << "b: " << b << ",   ";
    fileOut << "t1: " << t1 << ",   ";
    fileOut << "t2: " << t2 << ",   ";
    fileOut << "\n";
    fileOut << "Voltage: " << Vext << " ";
    fileOut << "\n";
    fileOut << "Current: " << J << " ";
    fileOut << "\n";
    fileOut << "N: " << N << " ";
    fileOut << "\n";
    fileOut.close();
    
    GeomPlotter geomplotter( geom );
    geomplotter.set_size( 1280, 1280 );
    geomplotter.set_epot( &epot );
    geomplotter.set_particle_database( &pdb );
    geomplotter.set_view( VIEW_ZX);
    geomplotter.plot_png( "plot_zx.png" );
    geomplotter.set_view( VIEW_ZY);
    geomplotter.plot_png( "plot_zy.png" );

    
    if( false ) {
        MeshScalarField tdens( geom );
        pdb.build_trajectory_density_field( tdens );
        GTKPlotter plotter( argc, argv );
        plotter.set_geometry( &geom );
        plotter.set_epot( &epot );
        plotter.set_bfield( &bfield );
        plotter.set_efield( &efield );
        plotter.set_scharge( &scharge );
        plotter.set_trajdens( &tdens );
        plotter.set_particledatabase( &pdb );
        plotter.new_geometry_plot_window();
	plotter.new_particle_plot_window( AXIS_Z, 0.03, PARTICLE_DIAG_PLOT_SCATTER, DIAG_VZ, DIAG_VX);
        plotter.run();	
    }
    
}

int main( int argc, char **argv )
{
    try {
        ibsimu.set_message_threshold( MSG_VERBOSE, 1 );
	ibsimu.set_thread_count( 4 );
        simu( &argc, &argv );
    } catch ( Error e ) {
	e.print_error_message( ibsimu.message( 0 ) );
        exit( 1 );
    }

    return( 0 );
}
